#! /usr/bin/env node
'use strict';

var _assign = require('babel-runtime/core-js/object/assign');

var _assign2 = _interopRequireDefault(_assign);

var _slicedToArray2 = require('babel-runtime/helpers/slicedToArray');

var _slicedToArray3 = _interopRequireDefault(_slicedToArray2);

var _keys = require('babel-runtime/core-js/object/keys');

var _keys2 = _interopRequireDefault(_keys);

var _path = require('path');

var _path2 = _interopRequireDefault(_path);

var _yargs = require('yargs');

var _yargs2 = _interopRequireDefault(_yargs);

require('colors');

var _lib = require('./lib');

var _lib2 = _interopRequireDefault(_lib);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var _yargs$usage$demand$d = _yargs2.default.usage("Usage: migrate -d <mongo-uri> [[create|up|down <migration-name>]|list] [optional options]").demand(1).default('config', 'migrate').config('config', 'filepath to an options configuration json file', function (pathToConfigFile) {
  // Get any args from env vars
  var envs = process.env;
  var envVarOptions = {};
  (0, _keys2.default)(envs).map(function (key) {
    if (key.includes('MIGRATE_')) {
      var _key$match = key.match(/MIGRATE_(.*$)/),
          _key$match2 = (0, _slicedToArray3.default)(_key$match, 2),
          option = _key$match2[1];

      envVarOptions[option] = envs[key];
    }
  });

  var configOptions = {};
  try {
    configOptions = require(pathToConfigFile);
  } catch (err) {/* noop */}
  return (0, _assign2.default)({}, configOptions, envVarOptions);
}).command('list'.cyan, 'Lists all migrations and their current state.').example('$0 list').command('create <migration-name>'.cyan, 'Creates a new migration file.').example('$0 create add_users').command('up [migration-name]'.cyan, 'Migrates all the migration files that have not yet been run in chronological order. ' + 'Not including [migration-name] will run UP on all migrations that are in a DOWN state.').example('$0 up add_user').command('down <migration-name>'.cyan, 'Rolls back migrations down to given name (if down function was provided)').example('$0 down delete_names').command('prune'.cyan, 'Allows you to delete extraneous migrations by removing extraneous local migration files/database migrations.').example('$0 prune').option('collection', {
  type: 'string',
  default: 'migrations',
  description: 'The collection to use for the migrations',
  nargs: 1
}).option('d', {
  demand: true,
  type: 'string',
  alias: 'dbConnectionUri',
  description: 'The URI of the database connection'.yellow,
  nargs: 1
}).option('es6', {
  type: 'boolean',
  description: 'use es6 migration template?'
}).option('md', {
  alias: 'migrations-dir',
  description: 'The path to the migration files',
  normalize: true,
  default: './migrations',
  nargs: 1
}).option('t', {
  alias: 'template-file',
  description: 'The template file to use when creating a migration',
  type: 'string',
  normalize: true,
  nargs: 1
}).option('c', {
  alias: 'change-dir',
  type: 'string',
  normalize: 'true',
  description: 'Change current working directory before running anything',
  nargs: 1
}).option('autosync', {
  type: 'boolean',
  description: 'Automatically add new migrations in the migrations folder to the database instead of asking interactively'
}).help('h').alias('h', 'help'),
    args = _yargs$usage$demand$d.argv;

// Destructure the command and following argument


var _args$_ = (0, _slicedToArray3.default)(args._, 2),
    command = _args$_[0],
    _args$_$ = _args$_[1],
    migrationName = _args$_$ === undefined ? args['migration-name'] : _args$_$;

if (!command) process.exit(1);

// Change directory before anything if the option was provided
if (args.c) process.chdir(args.c);

// Make sure we have a connection URI
if (!args.dbConnectionUri) {
  console.error('You need to provide the Mongo URI to persist migration status.\nUse option --dbConnectionUri / -d to provide the URI.'.red);
  process.exit(1);
}

var migrator = new _lib2.default({
  migrationsPath: _path2.default.resolve(args['migrations-dir']),
  templatePath: args['template-file'],
  dbConnectionUri: args.dbConnectionUri,
  es6Templates: args.es6,
  collectionName: args.collection,
  autosync: args.autosync,
  cli: true
});

var promise = void 0;
switch (command) {
  case 'create':
    validateSubArgs({ min: 1, max: 1, desc: 'You must provide only the name of the migration to create.'.red });
    promise = migrator.create(migrationName);
    promise.then(function () {
      console.log('Migration created. Run ' + ('mongoose-migrate up ' + migrationName).cyan + ' to apply the migration.');
    });
    break;
  case 'up':
    validateSubArgs({ max: 1, desc: 'Command "up" takes 0 or 1 arguments'.red });
    promise = migrator.run('up', migrationName);
    break;
  case 'down':
    validateSubArgs({ min: 1, max: 1, desc: 'You must provide the name of the migration to stop at when migrating down.'.red });
    promise = migrator.run('down', migrationName);
    break;
  case 'list':
    validateSubArgs({ max: 0, desc: 'Command "list" does not take any arguments'.yellow });
    promise = migrator.list();
    break;
  case 'prune':
    validateSubArgs({ max: 0, desc: 'Command "prune" does not take any arguments'.yellow });
    promise = migrator.prune();
    break;
  default:
    _yargs2.default.showHelp();
    process.exit(0);
}

promise.then(function () {
  process.exit(0);
}).catch(function (err) {
  console.warn(err.message.yellow);
  process.exit(1);
});

function validateSubArgs(_ref) {
  var _ref$min = _ref.min,
      min = _ref$min === undefined ? 0 : _ref$min,
      _ref$max = _ref.max,
      max = _ref$max === undefined ? Infinity : _ref$max,
      desc = _ref.desc;

  var argsLen = args._.length - 1;
  if (argsLen < min || argsLen > max) {
    _yargs2.default.showHelp();
    console.error(desc);
    process.exit(-1);
  }
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uL3NyYy9jbGkuanMiXSwibmFtZXMiOlsidXNhZ2UiLCJkZW1hbmQiLCJkZWZhdWx0IiwiY29uZmlnIiwiZW52cyIsInByb2Nlc3MiLCJlbnYiLCJlbnZWYXJPcHRpb25zIiwibWFwIiwia2V5IiwiaW5jbHVkZXMiLCJtYXRjaCIsIm9wdGlvbiIsImNvbmZpZ09wdGlvbnMiLCJyZXF1aXJlIiwicGF0aFRvQ29uZmlnRmlsZSIsImVyciIsImNvbW1hbmQiLCJjeWFuIiwiZXhhbXBsZSIsInR5cGUiLCJkZXNjcmlwdGlvbiIsIm5hcmdzIiwiYWxpYXMiLCJ5ZWxsb3ciLCJub3JtYWxpemUiLCJoZWxwIiwiYXJncyIsImFyZ3YiLCJfIiwibWlncmF0aW9uTmFtZSIsImV4aXQiLCJjIiwiY2hkaXIiLCJkYkNvbm5lY3Rpb25VcmkiLCJjb25zb2xlIiwiZXJyb3IiLCJyZWQiLCJtaWdyYXRvciIsIm1pZ3JhdGlvbnNQYXRoIiwicmVzb2x2ZSIsInRlbXBsYXRlUGF0aCIsImVzNlRlbXBsYXRlcyIsImVzNiIsImNvbGxlY3Rpb25OYW1lIiwiY29sbGVjdGlvbiIsImF1dG9zeW5jIiwiY2xpIiwicHJvbWlzZSIsInZhbGlkYXRlU3ViQXJncyIsIm1pbiIsIm1heCIsImRlc2MiLCJjcmVhdGUiLCJ0aGVuIiwibG9nIiwicnVuIiwibGlzdCIsInBydW5lIiwic2hvd0hlbHAiLCJjYXRjaCIsIndhcm4iLCJtZXNzYWdlIiwiSW5maW5pdHkiLCJhcmdzTGVuIiwibGVuZ3RoIl0sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7OztBQUVBOzs7O0FBQ0E7Ozs7QUFDQTs7QUFFQTs7Ozs7OzRCQUVzQixnQkFDbkJBLEtBRG1CLENBQ2IsMkZBRGEsRUFFbkJDLE1BRm1CLENBRVosQ0FGWSxFQUduQkMsT0FIbUIsQ0FHWCxRQUhXLEVBR0QsU0FIQyxFQUluQkMsTUFKbUIsQ0FLbEIsUUFMa0IsRUFNbEIsZ0RBTmtCLEVBT2xCLDRCQUFvQjtBQUNsQjtBQUNBLE1BQU1DLE9BQU9D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b3J0IHBhdGggZnJvbSAncGF0aCc7XG5pbXBvcnQgeWFyZ3MgZnJvbSAneWFyZ3MnO1xuaW1wb3J0ICdjb2xvcnMnO1xuXG5pbXBvcnQgTWlncmF0b3IgZnJvbSAnLi9saWInO1xuXG5sZXQgIHsgYXJndjogYXJncyB9ID0geWFyZ3NcbiAgLnVzYWdlKFwiVXNhZ2U6IG1pZ3JhdGUgLWQgPG1vbmdvLXVyaT4gW1tjcmVhdGV8dXB8ZG93biA8bWlncmF0aW9uLW5hbWU+XXxsaXN0XSBbb3B0aW9uYWwgb3B0aW9uc11cIilcbiAgLmRlbWFuZCgxKVxuICAuZGVmYXVsdCgnY29uZmlnJywgJ21pZ3JhdGUnKVxuICAuY29uZmlnKFxuICAgICdjb25maWcnLFxuICAgICdmaWxlcGF0aCB0byBhbiBvcHRpb25zIGNvbmZpZ3VyYXRpb24ganNvbiBmaWxlJyxcbiAgICBwYXRoVG9Db25maWdGaWxlID0+IHtcbiAgICAgIC8vIEdldCBhbnkgYXJncyBmcm9tIGVudiB2YXJzXG4gICAgICBjb25zdCBlbnZzID0gcHJvY2Vzcy5lbnY7XG4gICAgICBjb25zdCBlbnZWYXJPcHRpb25zID0ge307XG4gICAgICBPYmplY3Qua2V5cyhlbnZzKS5tYXAoKGtleSkgPT4ge1xuICAgICAgICBpZiAoa2V5LmluY2x1ZGVzKCdNSUdSQVRFXycpKSB7XG4gICAgICAgICAgY29uc3QgWywgb3B0aW9uXSA9IGtleS5tYXRjaCgvTUlHUkFURV8oLiokKS8pO1xuICAgICAgICAgIGVudlZhck9wdGlvbnNbb3B0aW9uXSA9IGVudnNba2V5XTtcbiAgICAgICAgfVxuICAgICAgfSk7XG5cbiAgICAgIGxldCBjb25maWdPcHRpb25zID0ge307XG4gICAgICB0cnkge1xuICAgICAgICBjb25maWdPcHRpb25zID0gcmVxdWlyZShwYXRoVG9Db25maWdGaWxlKVxuICAgICAgfSBjYXRjaCAoZXJyKSB7IC8qIG5vb3AgKi8gfVxuICAgICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oe30sIGNvbmZpZ09wdGlvbnMsIGVudlZhck9wdGlvbnMpO1xuICAgIH1cbiAgKVxuXG4gIC5jb21tYW5kKCdsaXN0Jy5jeWFuLCAnTGlzdHMgYWxsIG1pZ3JhdGlvbnMgYW5kIHRoZWlyIGN1cnJlbnQgc3RhdGUuJylcbiAgLmV4YW1wbGUoJyQwIGxpc3QnKVxuXG4gIC5jb21tYW5kKCdjcmVhdGUgPG1pZ3JhdGlvbi1uYW1lPicuY3lhbiwgJ0NyZWF0ZXMgYSBuZXcgbWlncmF0aW9uIGZpbGUuJylcbiAgLmV4YW1wbGUoJyQwIGNyZWF0ZSBhZGRfdXNlcnMnKVxuXG4gIC5jb21tYW5kKCd1cCBbbWlncmF0aW9uLW5hbWVdJy5jeWFuLFxuICAgICdNaWdyYXRlcyBhbGwgdGhlIG1pZ3JhdGlvbiBmaWxlcyB0aGF0IGhhdmUgbm90IHlldCBiZWVuIHJ1biBpbiBjaHJvbm9sb2dpY2FsIG9yZGVyLiAnICtcbiAgICAnTm90IGluY2x1ZGluZyBbbWlncmF0aW9uLW5hbWVdIHdpbGwgcnVuIFVQIG9uIGFsbCBtaWdyYXRpb25zIHRoYXQgYXJlIGluIGEgRE9XTiBzdGF0ZS4nKVxuICAuZXhhbXBsZSgnJDAgdXAgYWRkX3VzZXInKVxuXG4gIC5jb21tYW5kKCdkb3duIDxtaWdyYXRpb24tbmFtZT4nLmN5YW4sICdSb2xscyBiYWNrIG1pZ3JhdGlvbnMgZG93biB0byBnaXZlbiBuYW1lIChpZiBkb3duIGZ1bmN0aW9uIHdhcyBwcm92aWRlZCknKVxuICAuZXhhbXBsZSgnJDAgZG93biBkZWxldGVfbmFtZXMnKVxuXG4gIC5jb21tYW5kKCdwcnVuZScuY3lhbiwgJ0FsbG93cyB5b3UgdG8gZGVsZXRlIGV4dHJhbmVvdXMgbWlncmF0aW9ucyBieSByZW1vdmluZyBleHRyYW5lb3VzIGxvY2FsIG1pZ3JhdGlvbiBmaWxlcy9kYXRhYmFzZSBtaWdyYXRpb25zLicpXG4gIC5leGFtcGxlKCckMCBwcnVuZScpXG4gIC5vcHRpb24oJ2NvbGxlY3Rpb24nLCB7XG4gICAgdHlwZTogJ3N0cmluZycsXG4gICAgZGVmYXVsdDogJ21pZ3JhdGlvbnMnLFxuICAgIGRlc2NyaXB0aW9uOiAnVGhlIGNvbGxlY3Rpb24gdG8gdXNlIGZvciB0aGUgbWlncmF0aW9ucycsXG4gICAgbmFyZ3M6IDFcbiAgfSlcbiAgLm9wdGlvbignZCcsIHtcbiAgICBkZW1hbmQ6IHRydWUsXG4gICAgdHlwZTogJ3N0cmluZycsXG4gICAgYWxpYXM6ICdkYkNvbm5lY3Rpb25VcmknLFxuICAgIGRlc2NyaXB0aW9uOiAnVGhlIFVSSSBvZiB0aGUgZGF0YWJhc2UgY29ubmVjdGlvbicueWVsbG93LFxuICAgIG5hcmdzOiAxXG4gIH0pXG4gIC5vcHRpb24oJ2VzNicsIHtcbiAgICB0eXBlOiAnYm9vbGVhbicsXG4gICAgZGVzY3JpcHRpb246ICd1c2UgZXM2IG1pZ3JhdGlvbiB0ZW1wbGF0ZT8nXG4gIH0pXG4gIC5vcHRpb24oJ21kJywge1xuICAgIGFsaWFzOiAnbWlncmF0aW9ucy1kaXInLFxuICAgIGRlc2NyaXB0aW9uOiAnVGhlIHBhdGggdG8gdGhlIG1pZ3JhdGlvbiBmaWxlcycsXG4gICAgbm9ybWFsaXplOiB0cnVlLFxuICAgIGRlZmF1bHQ6ICcuL21pZ3JhdGlvbnMnLFxuICAgIG5hcmdzOiAxXG4gIH0pXG4gIC5vcHRpb24oJ3QnLCB7XG4gICAgYWxpYXM6ICd0ZW1wbGF0ZS1maWxlJyxcbiAgICBkZXNjcmlwdGlvbjogJ1RoZSB0ZW1wbGF0ZSBmaWxlIHRvIHVzZSB3aGVuIGNyZWF0aW5nIGEgbWlncmF0aW9uJyxcbiAgICB0eXBlOiAnc3RyaW5nJyxcbiAgICBub3JtYWxpemU6IHRydWUsXG4gICAgbmFyZ3M6IDFcbiAgfSlcblxuICAub3B0aW9uKCdjJywge1xuICAgIGFsaWFzOiAnY2hhbmdlLWRpcicsXG4gICAgdHlwZTogJ3N0cmluZycsXG4gICAgbm9ybWFsaXplOid0cnVlJyxcbiAgICBkZXNjcmlwdGlvbjogJ0NoYW5nZSBjdXJyZW50IHdvcmtpbmcgZGlyZWN0b3J5IGJlZm9yZSBydW5uaW5nIGFueXRoaW5nJyxcbiAgICBuYXJnczogMVxuICB9KVxuXG4gIC5vcHRpb24oJ2F1dG9zeW5jJywge1xuICAgIHR5cGU6ICdib29sZWFuJyxcbiAgICBkZXNjcmlwdGlvbjogJ0F1dG9tYXRpY2FsbHkgYWRkIG5ldyBtaWdyYXRpb25zIGluIHRoZSBtaWdyYXRpb25zIGZvbGRlciB0byB0aGUgZGF0YWJhc2UgaW5zdGVhZCBvZiBhc2tpbmcgaW50ZXJhY3RpdmVseSdcbiAgfSlcblxuICAuaGVscCgnaCcpXG4gIC5hbGlhcygnaCcsICdoZWxwJyk7XG5cbi8vIERlc3RydWN0dXJlIHRoZSBjb21tYW5kIGFuZCBmb2xsb3dpbmcgYXJndW1lbnRcbmNvbnN0IFsgY29tbWFuZCwgbWlncmF0aW9uTmFtZSA9IGFyZ3NbJ21pZ3JhdGlvbi1uYW1lJ10gXSA9IGFyZ3MuXztcblxuaWYgKCFjb21tYW5kKSBwcm9jZXNzLmV4aXQoMSk7XG5cbi8vIENoYW5nZSBkaXJlY3RvcnkgYmVmb3JlIGFueXRoaW5nIGlmIHRoZSBvcHRpb24gd2FzIHByb3ZpZGVkXG5pZiAoYXJncy5jKSBwcm9jZXNzLmNoZGlyKGFyZ3MuYyk7XG5cbi8vIE1ha2Ugc3VyZSB3ZSBoYXZlIGEgY29ubmVjdGlvbiBVUklcbmlmICghYXJncy5kYkNvbm5lY3Rpb25VcmkpIHtcbiAgY29uc29sZS5lcnJvcignWW91IG5lZWQgdG8gcHJvdmlkZSB0aGUgTW9uZ28gVVJJIHRvIHBlcnNpc3QgbWlncmF0aW9uIHN0YXR1cy5cXG5Vc2Ugb3B0aW9uIC0tZGJDb25uZWN0aW9uVXJpIC8gLWQgdG8gcHJvdmlkZSB0aGUgVVJJLicucmVkKTtcbiAgcHJvY2Vzcy5leGl0KDEpO1xufVxuXG5sZXQgbWlncmF0b3IgPSBuZXcgTWlncmF0b3Ioe1xuICBtaWdyYXRpb25zUGF0aDogIHBhdGgucmVzb2x2ZShhcmdzWydtaWdyYXRpb25zLWRpciddKSxcbiAgdGVtcGxhdGVQYXRoOiBhcmdzWyd0ZW1wbGF0ZS1maWxlJ10sXG4gIGRiQ29ubmVjdGlvblVyaTogYXJncy5kYkNvbm5lY3Rpb25VcmksXG4gIGVzNlRlbXBsYXRlczogYXJncy5lczYsXG4gIGNvbGxlY3Rpb25OYW1lOiAgYXJncy5jb2xsZWN0aW9uLFxuICBhdXRvc3luYzogYXJncy5hdXRvc3luYyxcbiAgY2xpOiB0cnVlXG59KTtcblxubGV0IHByb21pc2U7XG5zd2l0Y2goY29tbWFuZCkge1xuICBjYXNlICdjcmVhdGUnOlxuICAgIHZhbGlkYXRlU3ViQXJncyh7IG1pbjogMSwgbWF4OiAxLCBkZXNjOiAnWW91IG11c3QgcHJvdmlkZSBvbmx5IHRoZSBuYW1lIG9mIHRoZSBtaWdyYXRpb24gdG8gY3JlYXRlLicucmVkIH0pO1xuICAgIHByb21pc2UgPSBtaWdyYXRvci5jcmVhdGUobWlncmF0aW9uTmFtZSk7XG4gICAgcHJvbWlzZS50aGVuKCgpPT4ge1xuICAgICAgY29uc29sZS5sb2coYE1pZ3JhdGlvbiBjcmVhdGVkLiBSdW4gYCsgYG1vbmdvb3NlLW1pZ3JhdGUgdXAgJHttaWdyYXRpb25OYW1lfWAuY3lhbiArIGAgdG8gYXBwbHkgdGhlIG1pZ3JhdGlvbi5gKTtcbiAgICB9KTtcbiAgICBicmVhaztcbiAgY2FzZSAndXAnOlxuICAgIHZhbGlkYXRlU3ViQXJncyh7IG1heDogMSwgZGVzYzogJ0NvbW1hbmQgXCJ1cFwiIHRha2VzIDAgb3IgMSBhcmd1bWVudHMnLnJlZCB9KTtcbiAgICBwcm9taXNlID0gbWlncmF0b3IucnVuKCd1cCcsIG1pZ3JhdGlvbk5hbWUpO1xuICAgIGJyZWFrO1xuICBjYXNlICdkb3duJzpcbiAgICB2YWxpZGF0ZVN1YkFyZ3MoeyBtaW46IDEsIG1heDogMSwgZGVzYzogJ1lvdSBtdXN0IHByb3ZpZGUgdGhlIG5hbWUgb2YgdGhlIG1pZ3JhdGlvbiB0byBzdG9wIGF0IHdoZW4gbWlncmF0aW5nIGRvd24uJy5yZWQgfSk7XG4gICAgcHJvbWlzZSA9IG1pZ3JhdG9yLnJ1bignZG93bicsIG1pZ3JhdGlvbk5hbWUpO1xuICAgIGJyZWFrO1xuICBjYXNlICdsaXN0JzpcbiAgICB2YWxpZGF0ZVN1YkFyZ3MoeyBtYXg6IDAsIGRlc2M6ICdDb21tYW5kIFwibGlzdFwiIGRvZXMgbm90IHRha2UgYW55IGFyZ3VtZW50cycueWVsbG93IH0pO1xuICAgIHByb21pc2UgPSBtaWdyYXRvci5saXN0KCk7XG4gICAgYnJlYWs7XG4gIGNhc2UgJ3BydW5lJzpcbiAgICB2YWxpZGF0ZVN1YkFyZ3MoeyBtYXg6IDAsIGRlc2M6ICdDb21tYW5kIFwicHJ1bmVcIiBkb2VzIG5vdCB0YWtlIGFueSBhcmd1bWVudHMnLnllbGxvdyB9KTtcbiAgICBwcm9taXNlID0gbWlncmF0b3IucHJ1bmUoKTtcbiAgICBicmVhaztcbiAgZGVmYXVsdDpcbiAgICB5YXJncy5zaG93SGVscCgpO1xuICAgIHByb2Nlc3MuZXhpdCgwKTtcbn1cblxucHJvbWlzZVxuICAudGhlbigoKSA9PiB7IHByb2Nlc3MuZXhpdCgwKTsgfSlcbiAgLmNhdGNoKChlcnIpID0+IHtcbiAgICBjb25zb2xlLndhcm4oZXJyLm1lc3NhZ2UueWVsbG93KTtcbiAgICBwcm9jZXNzLmV4aXQoMSk7XG4gIH0pO1xuXG5cblxuZnVuY3Rpb24gdmFsaWRhdGVTdWJBcmdzKHsgbWluID0gMCwgbWF4ID0gSW5maW5pdHksIGRlc2MgfSkge1xuICBjb25zdCBhcmdzTGVuID0gYXJncy5fLmxlbmd0aCAtIDE7XG4gIGlmIChhcmdzTGVuIDwgbWluIHx8IGFyZ3NMZW4gPiBtYXgpIHtcbiAgICB5YXJncy5zaG93SGVscCgpO1xuICAgIGNvbnNvbGUuZXJyb3IoZGVzYyk7XG4gICAgcHJvY2Vzcy5leGl0KC0xKTtcbiAgfVxufVxuIl19